// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: vehicle.sql

package models

import (
	"context"
)

const createVehicle = `-- name: CreateVehicle :one
INSERT INTO
    vehicles(license_plate, "type")
VALUES
    ($1, $2) RETURNING id, license_plate, type
`

type CreateVehicleParams struct {
	LicensePlate string
	Type         *int64
}

func (q *Queries) CreateVehicle(ctx context.Context, arg CreateVehicleParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, createVehicle, arg.LicensePlate, arg.Type)
	var i Vehicle
	err := row.Scan(&i.ID, &i.LicensePlate, &i.Type)
	return i, err
}

const getVehicle = `-- name: GetVehicle :one
SELECT
    id, license_plate, type
FROM
    vehicles
WHERE
    id = coalesce($1, id)
    AND license_plate = coalesce($2, license_plate)
LIMIT
    1
`

type GetVehicleParams struct {
	ID           *int64
	LicensePlate *string
}

func (q *Queries) GetVehicle(ctx context.Context, arg GetVehicleParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, getVehicle, arg.ID, arg.LicensePlate)
	var i Vehicle
	err := row.Scan(&i.ID, &i.LicensePlate, &i.Type)
	return i, err
}

const listVehicle = `-- name: ListVehicle :many
SELECT
    id, license_plate, type
FROM
    vehicles
ORDER BY
    id
`

func (q *Queries) ListVehicle(ctx context.Context) ([]Vehicle, error) {
	rows, err := q.db.Query(ctx, listVehicle)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vehicle
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(&i.ID, &i.LicensePlate, &i.Type); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVehicle = `-- name: UpdateVehicle :one
UPDATE
    vehicles
SET
    license_plate = coalesce($1, license_plate),
    "type" = coalesce($2, "type")
WHERE
    id = $3 RETURNING id, license_plate, type
`

type UpdateVehicleParams struct {
	LicensePlate *string
	Type         *int64
	ID           int64
}

func (q *Queries) UpdateVehicle(ctx context.Context, arg UpdateVehicleParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, updateVehicle, arg.LicensePlate, arg.Type, arg.ID)
	var i Vehicle
	err := row.Scan(&i.ID, &i.LicensePlate, &i.Type)
	return i, err
}
