// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: geolocation.sql

package models

import (
	"context"
	"time"

	"github.com/cridenour/go-postgis"
)

const createGeolocation = `-- name: CreateGeolocation :one
INSERT INTO
    geolocations (
        degree,
        location,
        speed,
        vehicle_id,
        variant_id,
        timestamp
    )
VALUES
    (
        $1,
        $2 :: EWKB,
        $3,
        $4,
        $5,
        $6
    ) RETURNING degree, location, speed, vehicle_id, variant_id, timestamp
`

type CreateGeolocationParams struct {
	Degree    float32
	Location  postgis.Point
	Speed     float32
	VehicleID int64
	VariantID int64
	Timestamp time.Time
}

func (q *Queries) CreateGeolocation(ctx context.Context, arg CreateGeolocationParams) (Geolocation, error) {
	row := q.db.QueryRow(ctx, createGeolocation,
		arg.Degree,
		arg.Location,
		arg.Speed,
		arg.VehicleID,
		arg.VariantID,
		arg.Timestamp,
	)
	var i Geolocation
	err := row.Scan(
		&i.Degree,
		&i.Location,
		&i.Speed,
		&i.VehicleID,
		&i.VariantID,
		&i.Timestamp,
	)
	return i, err
}

const getGeolocation = `-- name: GetGeolocation :one
SELECT
    degree, location, speed, vehicle_id, variant_id, timestamp
FROM
    geolocations
WHERE
    vehicle_id = coalesce($1, vehicle_id)
ORDER BY
    "timestamp" DESC
LIMIT
    1
`

func (q *Queries) GetGeolocation(ctx context.Context, vehicleID *int64) (Geolocation, error) {
	row := q.db.QueryRow(ctx, getGeolocation, vehicleID)
	var i Geolocation
	err := row.Scan(
		&i.Degree,
		&i.Location,
		&i.Speed,
		&i.VehicleID,
		&i.VariantID,
		&i.Timestamp,
	)
	return i, err
}

const listGeolocation = `-- name: ListGeolocation :many
SELECT
    degree, location, speed, vehicle_id, variant_id, timestamp
FROM
    geolocations
WHERE
    vehicle_id = coalesce($1, vehicle_id)
ORDER BY
    "timestamp" DESC
LIMIT
    $2
`

type ListGeolocationParams struct {
	VehicleID *int64
	Limit     int32
}

func (q *Queries) ListGeolocation(ctx context.Context, arg ListGeolocationParams) ([]Geolocation, error) {
	rows, err := q.db.Query(ctx, listGeolocation, arg.VehicleID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Geolocation
	for rows.Next() {
		var i Geolocation
		if err := rows.Scan(
			&i.Degree,
			&i.Location,
			&i.Speed,
			&i.VehicleID,
			&i.VariantID,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
