// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: geolocation.sql

package models

import (
	"context"
	"time"
)

const createGeolocation = `-- name: CreateGeolocation :one
INSERT INTO
    geolocations (
        degree,
        latitude,
        longitude,
        speed,
        vehicle_id,
        variant_id,
        "timestamp"
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7) RETURNING degree, latitude, longitude, speed, vehicle_id, variant_id, timestamp
`

type CreateGeolocationParams struct {
	Degree    float32
	Latitude  float64
	Longitude float64
	Speed     float32
	VehicleID int64
	VariantID int64
	Timestamp time.Time
}

func (q *Queries) CreateGeolocation(ctx context.Context, arg CreateGeolocationParams) (Geolocation, error) {
	row := q.db.QueryRow(ctx, createGeolocation,
		arg.Degree,
		arg.Latitude,
		arg.Longitude,
		arg.Speed,
		arg.VehicleID,
		arg.VariantID,
		arg.Timestamp,
	)
	var i Geolocation
	err := row.Scan(
		&i.Degree,
		&i.Latitude,
		&i.Longitude,
		&i.Speed,
		&i.VehicleID,
		&i.VariantID,
		&i.Timestamp,
	)
	return i, err
}

const getGeolocation = `-- name: GetGeolocation :one
SELECT
    degree, latitude, longitude, speed, vehicle_id, variant_id, timestamp
FROM
    geolocations
WHERE
    vehicle_id = coalesce($1, vehicle_id)
ORDER BY
    "timestamp" DESC
LIMIT
    1
`

func (q *Queries) GetGeolocation(ctx context.Context, vehicleID *int64) (Geolocation, error) {
	row := q.db.QueryRow(ctx, getGeolocation, vehicleID)
	var i Geolocation
	err := row.Scan(
		&i.Degree,
		&i.Latitude,
		&i.Longitude,
		&i.Speed,
		&i.VehicleID,
		&i.VariantID,
		&i.Timestamp,
	)
	return i, err
}

const listGeolocation = `-- name: ListGeolocation :many
SELECT
    degree, latitude, longitude, speed, vehicle_id, variant_id, timestamp
FROM
    geolocations
WHERE
    vehicle_id = coalesce($1, vehicle_id)
ORDER BY
    "timestamp" DESC
LIMIT
    $2
`

type ListGeolocationParams struct {
	VehicleID *int64
	Limit     int32
}

func (q *Queries) ListGeolocation(ctx context.Context, arg ListGeolocationParams) ([]Geolocation, error) {
	rows, err := q.db.Query(ctx, listGeolocation, arg.VehicleID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Geolocation
	for rows.Next() {
		var i Geolocation
		if err := rows.Scan(
			&i.Degree,
			&i.Latitude,
			&i.Longitude,
			&i.Speed,
			&i.VehicleID,
			&i.VariantID,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
