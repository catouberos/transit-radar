// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: stop.sql

package models

import (
	"context"
)

const createStop = `-- name: CreateStop :one
INSERT INTO
    stops (
        code,
        name,
        type_id,
        ebms_id,
        active,
        latitude,
        longitude
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7) RETURNING id, code, name, type_id, ebms_id, active, latitude, longitude
`

type CreateStopParams struct {
	Code      string
	Name      string
	TypeID    int64
	EbmsID    *int64
	Active    bool
	Latitude  float32
	Longitude float32
}

func (q *Queries) CreateStop(ctx context.Context, arg CreateStopParams) (Stop, error) {
	row := q.db.QueryRow(ctx, createStop,
		arg.Code,
		arg.Name,
		arg.TypeID,
		arg.EbmsID,
		arg.Active,
		arg.Latitude,
		arg.Longitude,
	)
	var i Stop
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.TypeID,
		&i.EbmsID,
		&i.Active,
		&i.Latitude,
		&i.Longitude,
	)
	return i, err
}

const getStop = `-- name: GetStop :one
SELECT
    id, code, name, type_id, ebms_id, active, latitude, longitude
FROM
    stops
WHERE
    id = coalesce($1, id)
    AND ebms_id = coalesce($2, ebms_id)
LIMIT
    1
`

type GetStopParams struct {
	ID     *int64
	EbmsID *int64
}

func (q *Queries) GetStop(ctx context.Context, arg GetStopParams) (Stop, error) {
	row := q.db.QueryRow(ctx, getStop, arg.ID, arg.EbmsID)
	var i Stop
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.TypeID,
		&i.EbmsID,
		&i.Active,
		&i.Latitude,
		&i.Longitude,
	)
	return i, err
}

const listStop = `-- name: ListStop :many
SELECT
    id, code, name, type_id, ebms_id, active, latitude, longitude
FROM
    stops
ORDER BY
    id
`

func (q *Queries) ListStop(ctx context.Context) ([]Stop, error) {
	rows, err := q.db.Query(ctx, listStop)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stop
	for rows.Next() {
		var i Stop
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.TypeID,
			&i.EbmsID,
			&i.Active,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStop = `-- name: UpdateStop :one
UPDATE
    stops
SET
    code = coalesce($1, code),
    name = coalesce($2, name),
    type_id = coalesce($3, type_id),
    ebms_id = coalesce($4, ebms_id),
    active = coalesce($5, active),
    latitude = coalesce($6, latitude),
    longitude = coalesce($7, longitude)
WHERE
    id = $8 RETURNING id, code, name, type_id, ebms_id, active, latitude, longitude
`

type UpdateStopParams struct {
	Code      *string
	Name      *string
	TypeID    *int64
	EbmsID    *int64
	Active    *bool
	Latitude  *float32
	Longitude *float32
	ID        int64
}

func (q *Queries) UpdateStop(ctx context.Context, arg UpdateStopParams) (Stop, error) {
	row := q.db.QueryRow(ctx, updateStop,
		arg.Code,
		arg.Name,
		arg.TypeID,
		arg.EbmsID,
		arg.Active,
		arg.Latitude,
		arg.Longitude,
		arg.ID,
	)
	var i Stop
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.TypeID,
		&i.EbmsID,
		&i.Active,
		&i.Latitude,
		&i.Longitude,
	)
	return i, err
}
