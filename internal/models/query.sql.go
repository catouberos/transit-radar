// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGeolocation = `-- name: CreateGeolocation :one
INSERT INTO
    geolocations (
        degree,
        latitude,
        longitude,
        speed,
        vehicle_id,
        variant_id,
        "timestamp"
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7) RETURNING degree, latitude, longitude, speed, vehicle_id, variant_id, timestamp
`

type CreateGeolocationParams struct {
	Degree    float32
	Latitude  float32
	Longitude float32
	Speed     float32
	VehicleID int64
	VariantID int64
	Timestamp pgtype.Timestamptz
}

func (q *Queries) CreateGeolocation(ctx context.Context, arg CreateGeolocationParams) (Geolocation, error) {
	row := q.db.QueryRow(ctx, createGeolocation,
		arg.Degree,
		arg.Latitude,
		arg.Longitude,
		arg.Speed,
		arg.VehicleID,
		arg.VariantID,
		arg.Timestamp,
	)
	var i Geolocation
	err := row.Scan(
		&i.Degree,
		&i.Latitude,
		&i.Longitude,
		&i.Speed,
		&i.VehicleID,
		&i.VariantID,
		&i.Timestamp,
	)
	return i, err
}

const createOrUpdateRoute = `-- name: CreateOrUpdateRoute :one
INSERT INTO
    routes (
        number,
        name,
        ebms_id,
        operation_time,
        organization,
        ticketing,
        route_type
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7) ON CONFLICT (ebms_id) DO
UPDATE
SET
    number = EXCLUDED.number,
    name = EXCLUDED.name,
    operation_time = EXCLUDED.operation_time,
    organization = EXCLUDED.organization,
    ticketing = EXCLUDED.ticketing,
    route_type = EXCLUDED.route_type RETURNING id, number, name, ebms_id, active, operation_time, organization, ticketing, route_type
`

type CreateOrUpdateRouteParams struct {
	Number        string
	Name          string
	EbmsID        pgtype.Int8
	OperationTime pgtype.Text
	Organization  pgtype.Text
	Ticketing     pgtype.Text
	RouteType     pgtype.Text
}

func (q *Queries) CreateOrUpdateRoute(ctx context.Context, arg CreateOrUpdateRouteParams) (Route, error) {
	row := q.db.QueryRow(ctx, createOrUpdateRoute,
		arg.Number,
		arg.Name,
		arg.EbmsID,
		arg.OperationTime,
		arg.Organization,
		arg.Ticketing,
		arg.RouteType,
	)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.Name,
		&i.EbmsID,
		&i.Active,
		&i.OperationTime,
		&i.Organization,
		&i.Ticketing,
		&i.RouteType,
	)
	return i, err
}

const createOrUpdateStop = `-- name: CreateOrUpdateStop :exec
INSERT INTO
    stops(
        code,
        name,
        type_id,
        ebms_id,
        active,
        latitude,
        longitude
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7) ON CONFLICT(ebms_id) DO
UPDATE
SET
    code = EXCLUDED.code,
    name = EXCLUDED.name,
    type_id = EXCLUDED.type_id,
    active = EXCLUDED.active,
    latitude = EXCLUDED.latitude,
    longitude = EXCLUDED.longitude
`

type CreateOrUpdateStopParams struct {
	Code      string
	Name      string
	TypeID    int64
	EbmsID    pgtype.Int8
	Active    bool
	Latitude  float32
	Longitude float32
}

func (q *Queries) CreateOrUpdateStop(ctx context.Context, arg CreateOrUpdateStopParams) error {
	_, err := q.db.Exec(ctx, createOrUpdateStop,
		arg.Code,
		arg.Name,
		arg.TypeID,
		arg.EbmsID,
		arg.Active,
		arg.Latitude,
		arg.Longitude,
	)
	return err
}

const createOrUpdateVariant = `-- name: CreateOrUpdateVariant :one
INSERT INTO
    variants (
        name,
        ebms_id,
        is_outbound,
        route_id,
        description,
        short_name,
        distance,
        duration,
        start_stop_name,
        end_stop_name
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) ON CONFLICT (is_outbound, route_id) DO
UPDATE
SET
    name = EXCLUDED.name,
    description = EXCLUDED.description,
    short_name = EXCLUDED.short_name,
    distance = EXCLUDED.distance,
    duration = EXCLUDED.duration,
    start_stop_name = EXCLUDED.start_stop_name,
    end_stop_name = EXCLUDED.end_stop_name RETURNING id, name, ebms_id, is_outbound, route_id, description, short_name, distance, duration, start_stop_name, end_stop_name
`

type CreateOrUpdateVariantParams struct {
	Name          string
	EbmsID        pgtype.Int8
	IsOutbound    bool
	RouteID       int64
	Description   pgtype.Text
	ShortName     pgtype.Text
	Distance      pgtype.Float4
	Duration      pgtype.Int4
	StartStopName pgtype.Text
	EndStopName   pgtype.Text
}

func (q *Queries) CreateOrUpdateVariant(ctx context.Context, arg CreateOrUpdateVariantParams) (Variant, error) {
	row := q.db.QueryRow(ctx, createOrUpdateVariant,
		arg.Name,
		arg.EbmsID,
		arg.IsOutbound,
		arg.RouteID,
		arg.Description,
		arg.ShortName,
		arg.Distance,
		arg.Duration,
		arg.StartStopName,
		arg.EndStopName,
	)
	var i Variant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EbmsID,
		&i.IsOutbound,
		&i.RouteID,
		&i.Description,
		&i.ShortName,
		&i.Distance,
		&i.Duration,
		&i.StartStopName,
		&i.EndStopName,
	)
	return i, err
}

const createStopType = `-- name: CreateStopType :one
INSERT INTO
    stop_types (name)
VALUES
    ($1) RETURNING id, name
`

func (q *Queries) CreateStopType(ctx context.Context, name string) (StopType, error) {
	row := q.db.QueryRow(ctx, createStopType, name)
	var i StopType
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const createVariantStop = `-- name: CreateVariantStop :one
INSERT INTO
    variants_stops(variant_id, stop_id, order_score)
VALUES
    ($1, $2, $3) RETURNING variant_id, stop_id, order_score
`

type CreateVariantStopParams struct {
	VariantID  int64
	StopID     int64
	OrderScore int32
}

func (q *Queries) CreateVariantStop(ctx context.Context, arg CreateVariantStopParams) (VariantsStop, error) {
	row := q.db.QueryRow(ctx, createVariantStop, arg.VariantID, arg.StopID, arg.OrderScore)
	var i VariantsStop
	err := row.Scan(&i.VariantID, &i.StopID, &i.OrderScore)
	return i, err
}

const createVehicle = `-- name: CreateVehicle :one
INSERT INTO
    vehicles(license_plate)
VALUES
    ($1) RETURNING id, license_plate, type
`

func (q *Queries) CreateVehicle(ctx context.Context, licensePlate string) (Vehicle, error) {
	row := q.db.QueryRow(ctx, createVehicle, licensePlate)
	var i Vehicle
	err := row.Scan(&i.ID, &i.LicensePlate, &i.Type)
	return i, err
}

const getRoute = `-- name: GetRoute :one
SELECT
    id, number, name, ebms_id, active, operation_time, organization, ticketing, route_type
FROM
    routes
WHERE
    id = $1
LIMIT
    1
`

func (q *Queries) GetRoute(ctx context.Context, id int64) (Route, error) {
	row := q.db.QueryRow(ctx, getRoute, id)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.Name,
		&i.EbmsID,
		&i.Active,
		&i.OperationTime,
		&i.Organization,
		&i.Ticketing,
		&i.RouteType,
	)
	return i, err
}

const getRouteByEbmsID = `-- name: GetRouteByEbmsID :one
SELECT
    id, number, name, ebms_id, active, operation_time, organization, ticketing, route_type
FROM
    routes
WHERE
    ebms_id = $1
LIMIT
    1
`

func (q *Queries) GetRouteByEbmsID(ctx context.Context, ebmsID pgtype.Int8) (Route, error) {
	row := q.db.QueryRow(ctx, getRouteByEbmsID, ebmsID)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.Name,
		&i.EbmsID,
		&i.Active,
		&i.OperationTime,
		&i.Organization,
		&i.Ticketing,
		&i.RouteType,
	)
	return i, err
}

const getRouteByVariantID = `-- name: GetRouteByVariantID :one
SELECT
    degree, latitude, longitude, speed, vehicle_id, variant_id, timestamp
FROM
    geolocations
WHERE
    variant_id = $1
LIMIT
    1
`

func (q *Queries) GetRouteByVariantID(ctx context.Context, variantID int64) (Geolocation, error) {
	row := q.db.QueryRow(ctx, getRouteByVariantID, variantID)
	var i Geolocation
	err := row.Scan(
		&i.Degree,
		&i.Latitude,
		&i.Longitude,
		&i.Speed,
		&i.VehicleID,
		&i.VariantID,
		&i.Timestamp,
	)
	return i, err
}

const getStopByEbmsID = `-- name: GetStopByEbmsID :one
SELECT
    id, code, name, type_id, ebms_id, active, latitude, longitude
FROM
    stops
WHERE
    ebms_id = $1
LIMIT
    1
`

func (q *Queries) GetStopByEbmsID(ctx context.Context, ebmsID pgtype.Int8) (Stop, error) {
	row := q.db.QueryRow(ctx, getStopByEbmsID, ebmsID)
	var i Stop
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.TypeID,
		&i.EbmsID,
		&i.Active,
		&i.Latitude,
		&i.Longitude,
	)
	return i, err
}

const getStopTypeByName = `-- name: GetStopTypeByName :one
SELECT
    id, name
FROM
    stop_types
WHERE
    name = $1
LIMIT
    1
`

func (q *Queries) GetStopTypeByName(ctx context.Context, name string) (StopType, error) {
	row := q.db.QueryRow(ctx, getStopTypeByName, name)
	var i StopType
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getVariant = `-- name: GetVariant :one
SELECT
    id, name, ebms_id, is_outbound, route_id, description, short_name, distance, duration, start_stop_name, end_stop_name
FROM
    variants
WHERE
    id = $1
LIMIT
    1
`

func (q *Queries) GetVariant(ctx context.Context, id int64) (Variant, error) {
	row := q.db.QueryRow(ctx, getVariant, id)
	var i Variant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EbmsID,
		&i.IsOutbound,
		&i.RouteID,
		&i.Description,
		&i.ShortName,
		&i.Distance,
		&i.Duration,
		&i.StartStopName,
		&i.EndStopName,
	)
	return i, err
}

const getVariantByRouteEbmsID = `-- name: GetVariantByRouteEbmsID :one
SELECT
    variants.id, variants.name, variants.ebms_id, is_outbound, route_id, description, short_name, distance, duration, start_stop_name, end_stop_name, routes.id, number, routes.name, routes.ebms_id, active, operation_time, organization, ticketing, route_type
FROM
    public.variants
    LEFT OUTER JOIN routes ON routes.id = variants.route_id
WHERE
    variants.ebms_id = $1
    AND routes.ebms_id = $2
LIMIT
    1
`

type GetVariantByRouteEbmsIDParams struct {
	EbmsID   pgtype.Int8
	EbmsID_2 pgtype.Int8
}

type GetVariantByRouteEbmsIDRow struct {
	ID            int64
	Name          string
	EbmsID        pgtype.Int8
	IsOutbound    bool
	RouteID       int64
	Description   pgtype.Text
	ShortName     pgtype.Text
	Distance      pgtype.Float4
	Duration      pgtype.Int4
	StartStopName pgtype.Text
	EndStopName   pgtype.Text
	ID_2          pgtype.Int8
	Number        pgtype.Text
	Name_2        pgtype.Text
	EbmsID_2      pgtype.Int8
	Active        pgtype.Bool
	OperationTime pgtype.Text
	Organization  pgtype.Text
	Ticketing     pgtype.Text
	RouteType     pgtype.Text
}

func (q *Queries) GetVariantByRouteEbmsID(ctx context.Context, arg GetVariantByRouteEbmsIDParams) (GetVariantByRouteEbmsIDRow, error) {
	row := q.db.QueryRow(ctx, getVariantByRouteEbmsID, arg.EbmsID, arg.EbmsID_2)
	var i GetVariantByRouteEbmsIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EbmsID,
		&i.IsOutbound,
		&i.RouteID,
		&i.Description,
		&i.ShortName,
		&i.Distance,
		&i.Duration,
		&i.StartStopName,
		&i.EndStopName,
		&i.ID_2,
		&i.Number,
		&i.Name_2,
		&i.EbmsID_2,
		&i.Active,
		&i.OperationTime,
		&i.Organization,
		&i.Ticketing,
		&i.RouteType,
	)
	return i, err
}

const getVariantByRouteIDAndOutbound = `-- name: GetVariantByRouteIDAndOutbound :one
SELECT
    id, name, ebms_id, is_outbound, route_id, description, short_name, distance, duration, start_stop_name, end_stop_name
FROM
    variants
WHERE
    route_id = $1
    AND is_outbound = $2
LIMIT
    1
`

type GetVariantByRouteIDAndOutboundParams struct {
	RouteID    int64
	IsOutbound bool
}

func (q *Queries) GetVariantByRouteIDAndOutbound(ctx context.Context, arg GetVariantByRouteIDAndOutboundParams) (Variant, error) {
	row := q.db.QueryRow(ctx, getVariantByRouteIDAndOutbound, arg.RouteID, arg.IsOutbound)
	var i Variant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EbmsID,
		&i.IsOutbound,
		&i.RouteID,
		&i.Description,
		&i.ShortName,
		&i.Distance,
		&i.Duration,
		&i.StartStopName,
		&i.EndStopName,
	)
	return i, err
}

const getVariantStopByStopID = `-- name: GetVariantStopByStopID :many
SELECT
    variant_id, stop_id, order_score
FROM
    variants_stops
WHERE
    stop_id = $1
`

func (q *Queries) GetVariantStopByStopID(ctx context.Context, stopID int64) ([]VariantsStop, error) {
	rows, err := q.db.Query(ctx, getVariantStopByStopID, stopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VariantsStop
	for rows.Next() {
		var i VariantsStop
		if err := rows.Scan(&i.VariantID, &i.StopID, &i.OrderScore); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariantStopByVariantID = `-- name: GetVariantStopByVariantID :many
SELECT
    variant_id, stop_id, order_score
FROM
    variants_stops
WHERE
    variant_id = $1
`

func (q *Queries) GetVariantStopByVariantID(ctx context.Context, variantID int64) ([]VariantsStop, error) {
	rows, err := q.db.Query(ctx, getVariantStopByVariantID, variantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VariantsStop
	for rows.Next() {
		var i VariantsStop
		if err := rows.Scan(&i.VariantID, &i.StopID, &i.OrderScore); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehicleByLicensePlate = `-- name: GetVehicleByLicensePlate :one
SELECT
    id, license_plate, type
FROM
    vehicles
WHERE
    license_plate = $1
LIMIT
    1
`

func (q *Queries) GetVehicleByLicensePlate(ctx context.Context, licensePlate string) (Vehicle, error) {
	row := q.db.QueryRow(ctx, getVehicleByLicensePlate, licensePlate)
	var i Vehicle
	err := row.Scan(&i.ID, &i.LicensePlate, &i.Type)
	return i, err
}

const listRoute = `-- name: ListRoute :many
SELECT
    id, number, name, ebms_id, active, operation_time, organization, ticketing, route_type
FROM
    routes
ORDER BY
    id
`

func (q *Queries) ListRoute(ctx context.Context) ([]Route, error) {
	rows, err := q.db.Query(ctx, listRoute)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Route
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.ID,
			&i.Number,
			&i.Name,
			&i.EbmsID,
			&i.Active,
			&i.OperationTime,
			&i.Organization,
			&i.Ticketing,
			&i.RouteType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStop = `-- name: ListStop :many
SELECT
    id, code, name, type_id, ebms_id, active, latitude, longitude
FROM
    stops
ORDER BY
    id
`

func (q *Queries) ListStop(ctx context.Context) ([]Stop, error) {
	rows, err := q.db.Query(ctx, listStop)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stop
	for rows.Next() {
		var i Stop
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.TypeID,
			&i.EbmsID,
			&i.Active,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVariant = `-- name: ListVariant :many
SELECT
    id, name, ebms_id, is_outbound, route_id, description, short_name, distance, duration, start_stop_name, end_stop_name
FROM
    variants
ORDER BY
    id
`

func (q *Queries) ListVariant(ctx context.Context) ([]Variant, error) {
	rows, err := q.db.Query(ctx, listVariant)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Variant
	for rows.Next() {
		var i Variant
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.EbmsID,
			&i.IsOutbound,
			&i.RouteID,
			&i.Description,
			&i.ShortName,
			&i.Distance,
			&i.Duration,
			&i.StartStopName,
			&i.EndStopName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVariantByRouteId = `-- name: ListVariantByRouteId :many
SELECT
    id, name, ebms_id, is_outbound, route_id, description, short_name, distance, duration, start_stop_name, end_stop_name
FROM
    variants
WHERE
    route_id = $1
`

func (q *Queries) ListVariantByRouteId(ctx context.Context, routeID int64) ([]Variant, error) {
	rows, err := q.db.Query(ctx, listVariantByRouteId, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Variant
	for rows.Next() {
		var i Variant
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.EbmsID,
			&i.IsOutbound,
			&i.RouteID,
			&i.Description,
			&i.ShortName,
			&i.Distance,
			&i.Duration,
			&i.StartStopName,
			&i.EndStopName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
