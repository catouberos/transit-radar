// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: variant.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createVariant = `-- name: CreateVariant :one
INSERT INTO
    variants (
        name,
        ebms_id,
        is_outbound,
        route_id,
        description,
        short_name,
        distance,
        duration,
        start_stop_name,
        end_stop_name
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING id, name, ebms_id, is_outbound, route_id, description, short_name, distance, duration, start_stop_name, end_stop_name
`

type CreateVariantParams struct {
	Name          string
	EbmsID        pgtype.Int8
	IsOutbound    bool
	RouteID       int64
	Description   pgtype.Text
	ShortName     pgtype.Text
	Distance      pgtype.Float4
	Duration      pgtype.Int4
	StartStopName pgtype.Text
	EndStopName   pgtype.Text
}

func (q *Queries) CreateVariant(ctx context.Context, arg CreateVariantParams) (Variant, error) {
	row := q.db.QueryRow(ctx, createVariant,
		arg.Name,
		arg.EbmsID,
		arg.IsOutbound,
		arg.RouteID,
		arg.Description,
		arg.ShortName,
		arg.Distance,
		arg.Duration,
		arg.StartStopName,
		arg.EndStopName,
	)
	var i Variant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EbmsID,
		&i.IsOutbound,
		&i.RouteID,
		&i.Description,
		&i.ShortName,
		&i.Distance,
		&i.Duration,
		&i.StartStopName,
		&i.EndStopName,
	)
	return i, err
}

const getVariant = `-- name: GetVariant :one
SELECT
    id, name, ebms_id, is_outbound, route_id, description, short_name, distance, duration, start_stop_name, end_stop_name
FROM
    variants
WHERE
    id = $1
LIMIT
    1
`

func (q *Queries) GetVariant(ctx context.Context, id int64) (Variant, error) {
	row := q.db.QueryRow(ctx, getVariant, id)
	var i Variant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EbmsID,
		&i.IsOutbound,
		&i.RouteID,
		&i.Description,
		&i.ShortName,
		&i.Distance,
		&i.Duration,
		&i.StartStopName,
		&i.EndStopName,
	)
	return i, err
}

const getVariantByEbmsIDAndRouteEbmsID = `-- name: GetVariantByEbmsIDAndRouteEbmsID :one
SELECT
    variants.id, variants.name, variants.ebms_id, is_outbound, route_id, description, short_name, distance, duration, start_stop_name, end_stop_name, routes.id, number, routes.name, routes.ebms_id, active, operation_time, organization, ticketing, route_type
FROM
    variants
    LEFT OUTER JOIN routes ON routes.id = variants.route_id
WHERE
    variants.ebms_id = $1
    AND routes.ebms_id = $2
LIMIT
    1
`

type GetVariantByEbmsIDAndRouteEbmsIDParams struct {
	EbmsID   pgtype.Int8
	EbmsID_2 pgtype.Int8
}

type GetVariantByEbmsIDAndRouteEbmsIDRow struct {
	ID            int64
	Name          string
	EbmsID        pgtype.Int8
	IsOutbound    bool
	RouteID       int64
	Description   pgtype.Text
	ShortName     pgtype.Text
	Distance      pgtype.Float4
	Duration      pgtype.Int4
	StartStopName pgtype.Text
	EndStopName   pgtype.Text
	ID_2          pgtype.Int8
	Number        pgtype.Text
	Name_2        pgtype.Text
	EbmsID_2      pgtype.Int8
	Active        pgtype.Bool
	OperationTime pgtype.Text
	Organization  pgtype.Text
	Ticketing     pgtype.Text
	RouteType     pgtype.Text
}

func (q *Queries) GetVariantByEbmsIDAndRouteEbmsID(ctx context.Context, arg GetVariantByEbmsIDAndRouteEbmsIDParams) (GetVariantByEbmsIDAndRouteEbmsIDRow, error) {
	row := q.db.QueryRow(ctx, getVariantByEbmsIDAndRouteEbmsID, arg.EbmsID, arg.EbmsID_2)
	var i GetVariantByEbmsIDAndRouteEbmsIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EbmsID,
		&i.IsOutbound,
		&i.RouteID,
		&i.Description,
		&i.ShortName,
		&i.Distance,
		&i.Duration,
		&i.StartStopName,
		&i.EndStopName,
		&i.ID_2,
		&i.Number,
		&i.Name_2,
		&i.EbmsID_2,
		&i.Active,
		&i.OperationTime,
		&i.Organization,
		&i.Ticketing,
		&i.RouteType,
	)
	return i, err
}

const listVariant = `-- name: ListVariant :many
SELECT
    id, name, ebms_id, is_outbound, route_id, description, short_name, distance, duration, start_stop_name, end_stop_name
FROM
    variants
WHERE
    route_id = coalesce($1, route_id)
    AND coalesce($2, is_outbound)
ORDER BY
    id
`

type ListVariantParams struct {
	RouteID    pgtype.Int8
	IsOutbound interface{}
}

func (q *Queries) ListVariant(ctx context.Context, arg ListVariantParams) ([]Variant, error) {
	rows, err := q.db.Query(ctx, listVariant, arg.RouteID, arg.IsOutbound)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Variant
	for rows.Next() {
		var i Variant
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.EbmsID,
			&i.IsOutbound,
			&i.RouteID,
			&i.Description,
			&i.ShortName,
			&i.Distance,
			&i.Duration,
			&i.StartStopName,
			&i.EndStopName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVariant = `-- name: UpdateVariant :one
UPDATE
    variants
SET
    name = coalesce($1, name),
    ebms_id = coalesce($2, ebms_id),
    is_outbound = coalesce($3, is_outbound),
    route_id = coalesce($4, route_id),
    description = coalesce($5, description),
    short_name = coalesce($6, short_name),
    distance = coalesce($7, distance),
    duration = coalesce($8, duration),
    start_stop_name = coalesce($9, start_stop_name),
    end_stop_name = coalesce($10, end_stop_name)
WHERE
    id = $11 RETURNING id, name, ebms_id, is_outbound, route_id, description, short_name, distance, duration, start_stop_name, end_stop_name
`

type UpdateVariantParams struct {
	Name          pgtype.Text
	EbmsID        pgtype.Int8
	IsOutbound    pgtype.Bool
	RouteID       pgtype.Int8
	Description   pgtype.Text
	ShortName     pgtype.Text
	Distance      pgtype.Float4
	Duration      pgtype.Int4
	StartStopName pgtype.Text
	EndStopName   pgtype.Text
	ID            int64
}

func (q *Queries) UpdateVariant(ctx context.Context, arg UpdateVariantParams) (Variant, error) {
	row := q.db.QueryRow(ctx, updateVariant,
		arg.Name,
		arg.EbmsID,
		arg.IsOutbound,
		arg.RouteID,
		arg.Description,
		arg.ShortName,
		arg.Distance,
		arg.Duration,
		arg.StartStopName,
		arg.EndStopName,
		arg.ID,
	)
	var i Variant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EbmsID,
		&i.IsOutbound,
		&i.RouteID,
		&i.Description,
		&i.ShortName,
		&i.Distance,
		&i.Duration,
		&i.StartStopName,
		&i.EndStopName,
	)
	return i, err
}
