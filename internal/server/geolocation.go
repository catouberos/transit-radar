package server

import (
	"context"
	"log"

	"connectrpc.com/connect"
	"google.golang.org/protobuf/types/known/timestamppb"

	apiv1 "github.com/catouberos/transit-radar/gen/api/v1" // generated by protoc-gen-go
	"github.com/catouberos/transit-radar/internal/geolocation"
)

func (s *RPCServer) CreateGeolocation(
	ctx context.Context,
	req *connect.Request[apiv1.CreateGeolocationRequest],
) (*connect.Response[apiv1.CreateGeolocationResponse], error) {
	result, err := s.App.GeolocationService.Create(ctx, geolocation.CreateParams{
		Degree:    req.Msg.Degree,
		Latitude:  req.Msg.Latitude,
		Longitude: req.Msg.Longitude,
		Speed:     req.Msg.Speed,
		VehicleID: req.Msg.VehicleId,
		VariantID: req.Msg.VariantId,
		Timestamp: req.Msg.Timestamp.AsTime(),
	})
	if err != nil {
		return nil, err
	}

	res := connect.NewResponse(&apiv1.CreateGeolocationResponse{
		Geolocation: toResponseGeolocation(result),
	})
	return res, nil
}

func (s *RPCServer) GetVehiclesByRoute(
	ctx context.Context,
	req *connect.Request[apiv1.GetVehiclesByRouteRequest],
) (*connect.Response[apiv1.GetVehiclesByRouteResponse], error) {

	log.Println("Request headers: ", req.Header())
	res := connect.NewResponse(&apiv1.GetVehiclesByRouteResponse{
		Vehicles: nil,
	})
	return res, nil
}

func (s *RPCServer) GetVehiclesByStation(
	ctx context.Context,
	req *connect.Request[apiv1.GetVehiclesByStationRequest],
) (*connect.Response[apiv1.GetVehiclesByStationResponse], error) {
	log.Println("Request headers: ", req.Header())
	res := connect.NewResponse(&apiv1.GetVehiclesByStationResponse{
		Vehicles: nil,
	})
	return res, nil
}

func (s *RPCServer) ListGeolocationByBounding(
	ctx context.Context,
	req *connect.Request[apiv1.ListGeolocationByBoundingRequest],
) (*connect.Response[apiv1.ListGeolocationByBoundingResponse], error) {
	results, err := s.App.GeolocationService.ListByBounding(
		ctx,
		geolocation.ListByBoundingParams{
			Latitude:  req.Msg.Latitude,
			Longitude: req.Msg.Longitude,
			Width:     req.Msg.Width,
			Height:    req.Msg.Height,
		},
	)
	if err != nil {
		return nil, err
	}

	geolocations := make([]*apiv1.Geolocation, len(results))
	for i, result := range results {
		geolocations[i] = toResponseGeolocation(result)
	}

	res := connect.NewResponse(&apiv1.ListGeolocationByBoundingResponse{
		Geolocations: geolocations,
	})

	return res, nil
}

func toResponseGeolocation(geolocation geolocation.Geolocation) *apiv1.Geolocation {
	return &apiv1.Geolocation{
		Degree:    geolocation.Degree,
		Latitude:  geolocation.Latitude,
		Longitude: geolocation.Longitude,
		Speed:     geolocation.Speed,
		VehicleId: geolocation.VehicleID,
		VariantId: geolocation.VariantID,
		Timestamp: timestamppb.New(geolocation.Timestamp),
	}
}
